// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from "./client";
import { client } from "./client.gen";
import type {
  EmailConfirmGetData,
  EmailConfirmGetErrors,
  EmailConfirmGetResponses,
  EmailConfirmSendData,
  EmailConfirmSendErrors,
  EmailConfirmSendResponses,
  MeGetData,
  MeGetErrors,
  MeGetResponses,
  PasswordForgotData,
  PasswordForgotErrors,
  PasswordForgotResponses,
  PasswordResetData,
  PasswordResetErrors,
  PasswordResetResponses,
  SignInData,
  SignInErrors,
  SignInResponses,
  SignOutData,
  SignOutErrors,
  SignOutResponses,
  SignUpData,
  SignUpErrors,
  SignUpResponses,
} from "./types.gen";

export type Options<
  TData extends TDataShape = TDataShape,
  ThrowOnError extends boolean = boolean,
> = Options2<TData, ThrowOnError> & {
  /**
   * You can provide a client instance returned by `createClient()` instead of
   * individual options. This might be also useful if you want to implement a
   * custom client.
   */
  client?: Client;
  /**
   * You can pass arbitrary values through the `meta` object. This can be
   * used to access values that aren't defined as part of the SDK function.
   */
  meta?: Record<string, unknown>;
};

/**
 * Confirm email from a browser verification link (`GET /auth/email/confirm?token=...`).
 */
export const emailConfirmGet = <ThrowOnError extends boolean = false>(
  options: Options<EmailConfirmGetData, ThrowOnError>,
) => {
  return (options.client ?? client).get<
    EmailConfirmGetResponses,
    EmailConfirmGetErrors,
    ThrowOnError
  >({
    url: "/auth/email/confirm",
    ...options,
  });
};

/**
 * Send a confirmation email to the user.
 *
 * Creates a verification token and sends an email with the confirmation link.
 * Always returns success to prevent email enumeration attacks.
 */
export const emailConfirmSend = <ThrowOnError extends boolean = false>(
  options: Options<EmailConfirmSendData, ThrowOnError>,
) => {
  return (options.client ?? client).post<
    EmailConfirmSendResponses,
    EmailConfirmSendErrors,
    ThrowOnError
  >({
    url: "/auth/email/confirm/send",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Get current authenticated user.
 *
 * Returns the current user's information from the JWT token.
 * Queries the database to get fresh user data including email_confirmed_at and created_at.
 *
 * # Requires
 * - Valid JWT access token (httpOnly cookie)
 * - `auth::middleware::base` middleware applied to route
 */
export const meGet = <ThrowOnError extends boolean = false>(
  options?: Options<MeGetData, ThrowOnError>,
) => {
  return (options?.client ?? client).get<
    MeGetResponses,
    MeGetErrors,
    ThrowOnError
  >({
    url: "/auth/me",
    ...options,
  });
};

/**
 * Request a password reset email.
 *
 * Creates a reset token and sends an email with the reset link.
 * Always returns success to prevent email enumeration attacks.
 */
export const passwordForgot = <ThrowOnError extends boolean = false>(
  options: Options<PasswordForgotData, ThrowOnError>,
) => {
  return (options.client ?? client).post<
    PasswordForgotResponses,
    PasswordForgotErrors,
    ThrowOnError
  >({
    url: "/auth/password/forgot",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Reset password using the token from the email.
 */
export const passwordReset = <ThrowOnError extends boolean = false>(
  options: Options<PasswordResetData, ThrowOnError>,
) => {
  return (options.client ?? client).post<
    PasswordResetResponses,
    PasswordResetErrors,
    ThrowOnError
  >({
    url: "/auth/password/reset",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Sign in an existing user.
 *
 * Authenticates user with email and password.
 * Sets access and refresh tokens as httpOnly cookies.
 * Returns `EmailNotConfirmed` when `require_email_confirmation` is enabled and the user has not
 * confirmed their email.
 * Calls the `on_sign_in` hook after successful authentication.
 */
export const signIn = <ThrowOnError extends boolean = false>(
  options: Options<SignInData, ThrowOnError>,
) => {
  return (options.client ?? client).post<
    SignInResponses,
    SignInErrors,
    ThrowOnError
  >({
    url: "/auth/sign-in",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};

/**
 * Sign out user by revoking refresh token.
 *
 * Revokes the refresh token from database and clears both access and refresh cookies.
 * The server automatically sends Set-Cookie headers to clear the cookies from the browser.
 *
 * **Note**: Due to the stateless nature of JWT tokens, if the access token was copied before
 * sign-out, it will remain valid until it expires (typically 15 minutes). This is standard
 * behavior for JWT-based authentication systems.
 */
export const signOut = <ThrowOnError extends boolean = false>(
  options?: Options<SignOutData, ThrowOnError>,
) => {
  return (options?.client ?? client).post<
    SignOutResponses,
    SignOutErrors,
    ThrowOnError
  >({
    url: "/auth/sign-out",
    ...options,
  });
};

/**
 * Sign up a new user.
 *
 * Creates a new user account with email and password.
 * Sets access and refresh tokens as httpOnly cookies unless email confirmation is required.
 * Calls the `on_sign_up` hook after successful user creation.
 */
export const signUp = <ThrowOnError extends boolean = false>(
  options: Options<SignUpData, ThrowOnError>,
) => {
  return (options.client ?? client).post<
    SignUpResponses,
    SignUpErrors,
    ThrowOnError
  >({
    url: "/auth/sign-up",
    ...options,
    headers: {
      "Content-Type": "application/json",
      ...options.headers,
    },
  });
};
